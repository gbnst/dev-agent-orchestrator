# Template File Consolidation Implementation Plan

**Goal:** Consolidate template configuration by embedding all container orchestration settings directly into template files, eliminating separate `devcontainer.json`, `allowlist.txt`, and the Go code that parses them.

**Architecture:** Template directories become the single source of truth. `filter.py.tmpl` replaces allowlist parsing. `devcontainer.json.tmpl` becomes self-contained per template. The `Template` struct is stripped to `Name`, `Path`, and `PostCreateCommand`. All isolation config types and parsing code are removed.

**Tech Stack:** Go 1.21+, text/template, mitmproxy Python addon API

**Scope:** 5 phases from original design (phases 1-5)

**Codebase verified:** 2026-02-05

**Testing conventions:** Standard Go `testing` package only (no testify/gomock). Table-driven tests with `t.Run()`. Manual test doubles. `t.TempDir()` for filesystem tests. `make test` runs `go test ./...`. Reference: `internal/config/templates_test.go`, `internal/container/compose_test.go`. See also `internal/config/CLAUDE.md` and `internal/container/CLAUDE.md` for domain contracts.

---

## Phase 2: Add filter.py.tmpl and remove allowlist.txt

**Goal:** Create `filter.py.tmpl` template files for each template, remove `allowlist.txt` files, and update `ComposeGenerator` to process the new template instead of generating filter scripts from parsed allowlist data.

**Note: Tasks in this phase MUST be executed in strict numerical order.** Tasks 1-2 create template files, Tasks 3-7 modify Go code, Tasks 8-9 update tests and docs. Executing out of order will cause intermediate compilation failures.

<!-- START_SUBCOMPONENT_A (tasks 1-2) -->

<!-- START_TASK_1 -->
### Task 1: Create filter.py.tmpl for basic template

**Files:**
- Create: `config/templates/basic/filter.py.tmpl`

**Step 1: Create the filter.py.tmpl file**

Create `config/templates/basic/filter.py.tmpl` with the following content. This is a complete mitmproxy addon script with the allowlist hardcoded directly in the template. The `{{.CertInstallCommand}}` placeholder will be used by the devcontainer template in a later phase — for now this file has no Go template placeholders (all config is inlined).

```python
from mitmproxy import ctx, http
import re

# Allowlist of permitted domains
# Wildcards are supported: "*.github.com" matches "api.github.com"
ALLOWED_DOMAINS = [
    "api.anthropic.com",
    "claude.ai",
    "*.claude.ai",
    "platform.claude.com",
    "sentry.io",
    "*.sentry.io",
    "statsigapi.net",
    "github.com",
    "*.github.com",
    "api.github.com",
    "raw.githubusercontent.com",
    "objects.githubusercontent.com",
    "registry.npmjs.org",
    "pypi.org",
    "files.pythonhosted.org",
    "proxy.golang.org",
    "sum.golang.org",
    "storage.googleapis.com",
    "pkg.go.dev",
]

# Passthrough domains bypass TLS interception entirely (for certificate pinning).
# These are set via mitmproxy's ignore_hosts option in the load() hook below,
# replacing the previous --ignore-hosts CLI flag generated by Go code.
PASSTHROUGH_DOMAINS = []

# Block GitHub PR merge API calls.
# The @blockGitHubPRMerge flag from the old allowlist.txt format becomes this
# Python boolean. True = block merge API calls, False = allow them.
BLOCK_GITHUB_PR_MERGE = True


def load(loader):
    """Configure mitmproxy options at addon load time."""
    if PASSTHROUGH_DOMAINS:
        # Convert domain patterns to mitmproxy ignore_hosts regex format.
        # Each domain becomes a regex: "example.com" -> "^example\\.com$"
        # Wildcards: "*.example.com" -> "^.*\\.example\\.com$"
        patterns = []
        for domain in PASSTHROUGH_DOMAINS:
            if domain.startswith("*."):
                pattern = r"^.*\." + re.escape(domain[2:]) + "$"
            else:
                pattern = "^" + re.escape(domain) + "$"
            patterns.append(pattern)
        ctx.options.ignore_hosts = patterns


class AllowlistFilter:
    """Blocks requests to domains not in the allowlist and optionally blocks PR merges."""

    def _is_allowed(self, host: str) -> bool:
        """Check if host matches any allowed domain pattern."""
        for pattern in ALLOWED_DOMAINS:
            if pattern.startswith("*."):
                # Wildcard pattern: matches exact or any subdomain
                base = pattern[2:]  # Remove "*."
                if host == base or host.endswith("." + base):
                    return True
            elif host == pattern:
                return True
        return False

    def _is_github_pr_merge(self, flow: http.HTTPFlow) -> bool:
        """Check if request is a GitHub PR merge attempt."""
        if not BLOCK_GITHUB_PR_MERGE:
            return False

        host = flow.request.pretty_host
        if host not in ("api.github.com", "github.com") and not host.endswith(".github.com"):
            return False

        # REST API: PUT /repos/{owner}/{repo}/pulls/{number}/merge
        if flow.request.method == "PUT":
            if re.match(r"^/repos/[^/]+/[^/]+/pulls/\d+/merge$", flow.request.path):
                return True

        # GraphQL API: POST /graphql with mergePullRequest mutation
        if flow.request.method == "POST" and flow.request.path == "/graphql":
            content = flow.request.get_text()
            if content and "mergePullRequest" in content:
                return True

        return False

    def request(self, flow: http.HTTPFlow) -> None:
        # Check PR merge block first
        if self._is_github_pr_merge(flow):
            flow.response = http.Response.make(
                403,
                b"Merging pull requests is not allowed in this environment. Do not retry.\n",
                {"Content-Type": "text/plain"}
            )
            return

        host = flow.request.pretty_host
        if not self._is_allowed(host):
            flow.response = http.Response.make(
                403,
                f"Domain '{host}' is not in the allowlist\n".encode(),
                {"Content-Type": "text/plain"}
            )

addons = [AllowlistFilter()]
```

This is a static file (no Go template placeholders). It contains the same domains from `config/templates/basic/allowlist.txt` and the same filter logic from `internal/container/proxy.go:filterScriptTemplate`. The `load()` hook replaces the `--ignore-hosts` CLI flag previously generated by `buildProxyCommand()`/`GenerateIgnoreHostsPattern()` in Go code.

**Step 2: Commit**

```bash
git add config/templates/basic/filter.py.tmpl
git commit -m "feat: add filter.py.tmpl for basic template"
```
<!-- END_TASK_1 -->

<!-- START_TASK_2 -->
### Task 2: Create filter.py.tmpl for go-project template

**Files:**
- Create: `config/templates/go-project/filter.py.tmpl`

**Step 1: Create the filter.py.tmpl file**

Create `config/templates/go-project/filter.py.tmpl` with identical content to the basic template's filter.py.tmpl (investigation confirmed both allowlist.txt files have identical domains).

Copy the exact same content from Task 1's filter.py.tmpl.

**Step 2: Commit**

```bash
git add config/templates/go-project/filter.py.tmpl
git commit -m "feat: add filter.py.tmpl for go-project template"
```
<!-- END_TASK_2 -->

<!-- END_SUBCOMPONENT_A -->

<!-- START_SUBCOMPONENT_B (tasks 3-5) -->

<!-- START_TASK_3 -->
### Task 3: Update ComposeGenerator.Generate to use filter.py.tmpl

**Files:**
- Modify: `internal/container/compose.go`

**Step 1: Add CertInstallCommand field to TemplateData and remove ProxyCommand**

In `internal/container/compose.go`, replace the `TemplateData` struct (lines 26-36):

Replace:
```go
// TemplateData holds all values for template placeholder substitution.
// Only instance-specific values are substituted - everything else is hardcoded in templates.
type TemplateData struct {
	ProjectHash       string // 12-char SHA256 of project path
	ProjectPath       string // Absolute path to project
	ProjectName       string // Base name of project directory
	WorkspaceFolder   string // /workspaces/{{.ProjectName}}
	ClaudeConfigDir   string // Host path for persistent .claude directory
	TemplateName      string // Template name (e.g., "basic")
	ContainerName     string // Container name for devcontainer.json
	PostCreateCommand string // From template's devcontainer.json (optional)
	ProxyCommand      string // mitmproxy command with optional --ignore-hosts
}
```

With:
```go
// TemplateData holds all values for template placeholder substitution.
// Only instance-specific values are substituted - everything else is hardcoded in templates.
type TemplateData struct {
	ProjectHash       string // 12-char SHA256 of project path
	ProjectPath       string // Absolute path to project
	ProjectName       string // Base name of project directory
	WorkspaceFolder   string // /workspaces/{{.ProjectName}}
	ClaudeConfigDir   string // Host path for persistent .claude directory
	TemplateName      string // Template name (e.g., "basic")
	ContainerName     string // Container name for devcontainer.json
	PostCreateCommand string // From template's devcontainer.json (optional)
	CertInstallCommand string // Command to wait for, copy, and trust mitmproxy CA cert
}
```

**Step 2: Rewrite Generate() to process filter.py.tmpl**

Replace the `Generate()` method (lines 79-131) with:

```go
// Generate creates docker-compose.yml, Dockerfile.proxy, and filter.py content.
// Returns ComposeResult with all generated file contents.
func (g *ComposeGenerator) Generate(opts ComposeOptions) (*ComposeResult, error) {
	// Find template
	tmpl := g.GetTemplate(opts.Template)
	if tmpl == nil {
		return nil, fmt.Errorf("template not found: %s", opts.Template)
	}

	// Build template data
	data := g.buildTemplateData(opts, tmpl)

	// Process docker-compose.yml.tmpl
	composeYAML, err := g.processComposeTemplate(tmpl.Path, data)
	if err != nil {
		return nil, fmt.Errorf("failed to process docker-compose.yml.tmpl: %w", err)
	}

	// Load Dockerfile.proxy from template (static file)
	dockerfileProxy, err := g.loadDockerfileProxy(tmpl.Path)
	if err != nil {
		return nil, fmt.Errorf("failed to load Dockerfile.proxy: %w", err)
	}

	// Process filter.py.tmpl (currently static, but processed for consistency)
	filterScript, err := g.processFilterTemplate(tmpl.Path, data)
	if err != nil {
		return nil, fmt.Errorf("failed to process filter.py.tmpl: %w", err)
	}

	return &ComposeResult{
		ComposeYAML:     composeYAML,
		DockerfileProxy: dockerfileProxy,
		FilterScript:    filterScript,
	}, nil
}
```

**Step 3: Rewrite buildTemplateData() to remove allowlist parameter**

Replace `buildTemplateData` (lines 133-164) with:

```go
// buildTemplateData constructs TemplateData from options and template.
func (g *ComposeGenerator) buildTemplateData(opts ComposeOptions, tmpl *config.Template) TemplateData {
	hash := projectHash(opts.ProjectPath)
	projectName := filepath.Base(opts.ProjectPath)

	// Get postCreateCommand from template
	postCreateCommand := tmpl.PostCreateCommand

	// Chain cert installation to postCreateCommand
	// Wait for cert file to exist (proxy may still be starting), then copy and update trust store
	certInstallCmd := "timeout=30; while [ ! -f /tmp/mitmproxy-certs/mitmproxy-ca-cert.pem ] && [ $timeout -gt 0 ]; do sleep 1; timeout=$((timeout-1)); done && sudo cp /tmp/mitmproxy-certs/mitmproxy-ca-cert.pem /usr/local/share/ca-certificates/mitmproxy-ca-cert.crt && sudo update-ca-certificates"
	if postCreateCommand == "" {
		postCreateCommand = certInstallCmd
	} else {
		postCreateCommand = postCreateCommand + " && " + certInstallCmd
	}

	return TemplateData{
		ProjectHash:        hash,
		ProjectPath:        opts.ProjectPath,
		ProjectName:        projectName,
		WorkspaceFolder:    fmt.Sprintf("/workspaces/%s", projectName),
		ClaudeConfigDir:    getContainerClaudeDir(opts.ProjectPath),
		TemplateName:       tmpl.Name,
		ContainerName:      opts.Name,
		PostCreateCommand:  postCreateCommand,
		CertInstallCommand: certInstallCmd,
	}
}
```

**Step 4: Add processFilterTemplate method**

Add this method after `processComposeTemplate` (after line 186):

```go
// processFilterTemplate processes filter.py.tmpl with the given data.
func (g *ComposeGenerator) processFilterTemplate(templatePath string, data TemplateData) (string, error) {
	tmplFile := filepath.Join(templatePath, "filter.py.tmpl")
	return processTemplate(tmplFile, data)
}
```

**Step 5: Delete AllowlistConfig, LoadAllowlist, and buildProxyCommand**

Delete these from `internal/container/compose.go`:
- `AllowlistConfig` struct (lines 38-43)
- `buildProxyCommand` function (lines 166-180)
- `LoadAllowlist` function (lines 238-296)

**Step 6: Hardcode proxy command in real template files**

**Critical:** After removing `ProxyCommand` from `TemplateData`, the real template files at `config/templates/basic/docker-compose.yml.tmpl` and `config/templates/go-project/docker-compose.yml.tmpl` still contain `{{.ProxyCommand}}` at line 56. Go's `text/template` will error on undefined struct fields at execution time. Update them now.

In `config/templates/basic/docker-compose.yml.tmpl`, line 56, replace:

```yaml
    command: {{.ProxyCommand}}
```

With:

```yaml
    command: ["mitmdump", "--listen-host", "0.0.0.0", "--listen-port", "8080", "-s", "/home/mitmproxy/filter.py"]
```

In `config/templates/go-project/docker-compose.yml.tmpl`, line 56, make the same replacement.

**Step 7: Verify it compiles**

Run: `go build ./...`
Expected: Build succeeds (tests may still fail — test updates are in the next task)

**Step 8: Commit**

```bash
git add internal/container/compose.go config/templates/basic/docker-compose.yml.tmpl config/templates/go-project/docker-compose.yml.tmpl
git commit -m "refactor: update ComposeGenerator to process filter.py.tmpl, hardcode proxy command"
```
<!-- END_TASK_3 -->

<!-- START_TASK_4 -->
### Task 4: Delete unused proxy generation functions

**Files:**
- Modify: `internal/container/proxy.go`

**Step 1: Verify functions are unused before deletion**

Run: `grep -rn 'WriteFilterScript\|GenerateFilterScript\|GenerateIgnoreHostsPattern\|filterScriptTemplate' internal/ --include='*.go' | grep -v proxy.go | grep -v proxy_test.go`

Expected: No hits (all callers were in `compose.go` and were removed in Task 3). If any callers remain, fix them before proceeding.

**Step 2: Delete filter script generation functions**

Delete the following from `internal/container/proxy.go`:
- `filterScriptTemplate` constant (lines 15-82)
- `GenerateFilterScript` function (lines 84-97)
- `GenerateIgnoreHostsPattern` function (lines 99-121)
- `WriteFilterScript` function (lines 183-199)

**Important:** Keep these functions (they are still used by `manager.go` and `devcontainer.go`):
- `projectHash` (line 123-127)
- `GetProxyConfigDir` (lines 129-141)
- `GetProxyCertDir` (lines 143-155)
- `GetProxyCACertPath` (lines 157-165)
- `ProxyCertExists` (lines 167-181)
- `ReadAllowlistFromFilterScript` (lines 201-219)
- `parseAllowlistFromScript` (lines 221-257)
- `CleanupProxyConfigs` (lines 259-277)

After deletion, the remaining imports at the top of `proxy.go` should be:

```go
import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)
```

Remove the `"regexp"` import (only used by `GenerateIgnoreHostsPattern`).

**Step 3: Verify it compiles**

Run: `go build ./...`
Expected: Build succeeds

**Step 4: Commit**

```bash
git add internal/container/proxy.go
git commit -m "refactor: remove filter script generation code from proxy.go"
```
<!-- END_TASK_4 -->

<!-- START_TASK_5 -->
### Task 5: Update compose and proxy tests

**Files:**
- Modify: `internal/container/compose_test.go`
- Modify: `internal/container/proxy_test.go`

**Step 1: Update test helpers in compose_test.go**

Replace `createTestTemplateDir` (lines 40-143) with a version that creates `filter.py.tmpl` instead of `allowlist.txt`:

```go
// createTestTemplateDir creates a temporary template directory with template files.
// Returns the template directory path.
func createTestTemplateDir(t *testing.T, name string) string {
	t.Helper()

	tmpDir := t.TempDir()
	templateDir := filepath.Join(tmpDir, name)
	if err := os.MkdirAll(templateDir, 0755); err != nil {
		t.Fatalf("Failed to create template directory: %v", err)
	}

	// Create docker-compose.yml.tmpl
	composeContent := `services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: devagent-{{.ProjectHash}}-app
    depends_on:
      proxy:
        condition: service_started
    networks:
      - isolated
    environment:
      - http_proxy=http://devagent-{{.ProjectHash}}-proxy:8080
      - https_proxy=http://devagent-{{.ProjectHash}}-proxy:8080
      - HTTP_PROXY=http://devagent-{{.ProjectHash}}-proxy:8080
      - HTTPS_PROXY=http://devagent-{{.ProjectHash}}-proxy:8080
      - no_proxy=localhost,127.0.0.1
      - NO_PROXY=localhost,127.0.0.1
      - SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
      - REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
      - NODE_EXTRA_CA_CERTS=/etc/ssl/certs/ca-certificates.crt
    volumes:
      - {{.ProjectPath}}:{{.WorkspaceFolder}}:cached
      - proxy-certs:/tmp/mitmproxy-certs:ro
      - {{.ClaudeConfigDir}}:/home/vscode/.claude:cached
      - ${CLAUDE_TOKEN_PATH:-~/.claude/.devagent-claude-token}:/run/secrets/claude-token:ro
    cap_drop:
      - NET_RAW
      - SYS_ADMIN
      - SYS_PTRACE
    mem_limit: 4g
    cpus: "2"
    pids_limit: 512
    labels:
      devagent.managed: "true"
      devagent.project_path: "{{.ProjectPath}}"
      devagent.template: "{{.TemplateName}}"
    command: sleep infinity

  proxy:
    build:
      context: .
      dockerfile: Dockerfile.proxy
    container_name: devagent-{{.ProjectHash}}-proxy
    networks:
      - isolated
    volumes:
      - proxy-certs:/home/mitmproxy/.mitmproxy
    command: ["mitmdump", "--listen-host", "0.0.0.0", "--listen-port", "8080", "-s", "/home/mitmproxy/filter.py"]
    labels:
      devagent.managed: "true"
      devagent.sidecar_of: "{{.ProjectHash}}"
      devagent.sidecar_type: "proxy"

networks:
  isolated:
    name: devagent-{{.ProjectHash}}-net

volumes:
  proxy-certs:
`
	if err := os.WriteFile(filepath.Join(templateDir, "docker-compose.yml.tmpl"), []byte(composeContent), 0644); err != nil {
		t.Fatalf("Failed to write docker-compose.yml.tmpl: %v", err)
	}

	// Create Dockerfile.proxy
	dockerfileContent := `FROM mitmproxy/mitmproxy:latest
COPY filter.py /home/mitmproxy/filter.py
EXPOSE 8080
`
	if err := os.WriteFile(filepath.Join(templateDir, "Dockerfile.proxy"), []byte(dockerfileContent), 0644); err != nil {
		t.Fatalf("Failed to write Dockerfile.proxy: %v", err)
	}

	// Create filter.py.tmpl (static filter script for test)
	filterContent := `from mitmproxy import http
import re

ALLOWED_DOMAINS = [
    "api.anthropic.com",
    "github.com",
    "*.github.com",
    "registry.npmjs.org",
    "proxy.golang.org",
]

BLOCK_GITHUB_PR_MERGE = False

class AllowlistFilter:
    """Blocks requests to domains not in the allowlist and optionally blocks PR merges."""

    def _is_allowed(self, host: str) -> bool:
        """Check if host matches any allowed domain pattern."""
        for pattern in ALLOWED_DOMAINS:
            if pattern.startswith("*."):
                base = pattern[2:]
                if host == base or host.endswith("." + base):
                    return True
            elif host == pattern:
                return True
        return False

    def _is_github_pr_merge(self, flow: http.HTTPFlow) -> bool:
        """Check if request is a GitHub PR merge attempt."""
        if not BLOCK_GITHUB_PR_MERGE:
            return False
        host = flow.request.pretty_host
        if host not in ("api.github.com", "github.com") and not host.endswith(".github.com"):
            return False
        if flow.request.method == "PUT":
            if re.match(r"^/repos/[^/]+/[^/]+/pulls/\d+/merge$", flow.request.path):
                return True
        if flow.request.method == "POST" and flow.request.path == "/graphql":
            content = flow.request.get_text()
            if content and "mergePullRequest" in content:
                return True
        return False

    def request(self, flow: http.HTTPFlow) -> None:
        if self._is_github_pr_merge(flow):
            flow.response = http.Response.make(
                403,
                b"Merging pull requests is not allowed in this environment. Do not retry.\n",
                {"Content-Type": "text/plain"}
            )
            return
        host = flow.request.pretty_host
        if not self._is_allowed(host):
            flow.response = http.Response.make(
                403,
                f"Domain '{host}' is not in the allowlist\n".encode(),
                {"Content-Type": "text/plain"}
            )

addons = [AllowlistFilter()]
`
	if err := os.WriteFile(filepath.Join(templateDir, "filter.py.tmpl"), []byte(filterContent), 0644); err != nil {
		t.Fatalf("Failed to write filter.py.tmpl: %v", err)
	}

	return templateDir
}
```

Note: The `isolation` parameter is removed. The `ProxyCommand` in the docker-compose.yml.tmpl is now hardcoded (no longer a Go template placeholder).

**Step 2: Delete createTestTemplateWithPassthrough**

Delete the `createTestTemplateWithPassthrough` function (lines 146-219). It is no longer needed since passthrough domains are now hardcoded in the template's docker-compose.yml.tmpl.

**Step 3: Delete testIsolationConfig**

Delete the `testIsolationConfig` function (lines 14-36). It is no longer needed since tests no longer create `config.IsolationConfig`.

**Step 4: Update TestComposeGenerator_Generate_BasicTemplate**

Replace `TestComposeGenerator_Generate_BasicTemplate` (lines 221-297) with:

```go
func TestComposeGenerator_Generate_BasicTemplate(t *testing.T) {
	templateDir := createTestTemplateDir(t, "basic")

	templates := []config.Template{
		{
			Name: "basic",
			Path: templateDir,
		},
	}

	gen := NewComposeGenerator(templates)

	opts := ComposeOptions{
		ProjectPath: "/home/user/myproject",
		Template:    "basic",
		Name:        "test-container",
	}

	result, err := gen.Generate(opts)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	// Verify ComposeYAML contains expected services
	if !strings.Contains(result.ComposeYAML, "services:") {
		t.Error("ComposeYAML missing services section")
	}
	if !strings.Contains(result.ComposeYAML, "app:") {
		t.Error("ComposeYAML missing app service")
	}
	if !strings.Contains(result.ComposeYAML, "proxy:") {
		t.Error("ComposeYAML missing proxy service")
	}

	// Verify network definition
	if !strings.Contains(result.ComposeYAML, "networks:") {
		t.Error("ComposeYAML missing networks section")
	}
	if !strings.Contains(result.ComposeYAML, "isolated:") {
		t.Error("ComposeYAML missing isolated network")
	}

	// Verify volumes
	if !strings.Contains(result.ComposeYAML, "volumes:") {
		t.Error("ComposeYAML missing volumes section")
	}
	if !strings.Contains(result.ComposeYAML, "proxy-certs:") {
		t.Error("ComposeYAML missing proxy-certs volume")
	}
	if !strings.Contains(result.ComposeYAML, "/home/vscode/.claude:cached") {
		t.Error("ComposeYAML missing claude config volume mount")
	}
	if !strings.Contains(result.ComposeYAML, "/run/secrets/claude-token:ro") {
		t.Error("ComposeYAML missing oauth token volume mount")
	}

	// Verify Dockerfile.proxy content
	if !strings.Contains(result.DockerfileProxy, "FROM mitmproxy/mitmproxy") {
		t.Error("DockerfileProxy missing mitmproxy base image")
	}
	if !strings.Contains(result.DockerfileProxy, "COPY filter.py") {
		t.Error("DockerfileProxy missing filter.py COPY")
	}

	// Verify filter script from template
	if !strings.Contains(result.FilterScript, "ALLOWED_DOMAINS") {
		t.Error("FilterScript missing ALLOWED_DOMAINS")
	}
	if !strings.Contains(result.FilterScript, "api.anthropic.com") {
		t.Error("FilterScript missing expected domain")
	}
}
```

**Step 5: Update remaining compose tests**

Update `TestComposeGenerator_Generate_ContainerNaming` — remove `Image` and `Isolation` fields:

```go
func TestComposeGenerator_Generate_ContainerNaming(t *testing.T) {
	templateDir := createTestTemplateDir(t, "basic")

	templates := []config.Template{
		{Name: "basic", Path: templateDir},
	}

	gen := NewComposeGenerator(templates)

	opts := ComposeOptions{
		ProjectPath: "/home/user/myproject",
		Template:    "basic",
	}

	result, err := gen.Generate(opts)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	expectedHash := projectHash("/home/user/myproject")

	expectedAppName := "devagent-" + expectedHash + "-app"
	expectedProxyName := "devagent-" + expectedHash + "-proxy"
	expectedNetworkName := "devagent-" + expectedHash + "-net"

	if !strings.Contains(result.ComposeYAML, expectedAppName) {
		t.Errorf("ComposeYAML missing expected app container name: %s", expectedAppName)
	}
	if !strings.Contains(result.ComposeYAML, expectedProxyName) {
		t.Errorf("ComposeYAML missing expected proxy container name: %s", expectedProxyName)
	}
	if !strings.Contains(result.ComposeYAML, expectedNetworkName) {
		t.Errorf("ComposeYAML missing expected network name: %s", expectedNetworkName)
	}
}
```

Update `TestComposeGenerator_Generate_ProxyEnvironment` — remove `Image` and `Isolation` fields:

```go
func TestComposeGenerator_Generate_ProxyEnvironment(t *testing.T) {
	templateDir := createTestTemplateDir(t, "basic")

	templates := []config.Template{
		{Name: "basic", Path: templateDir},
	}

	gen := NewComposeGenerator(templates)

	opts := ComposeOptions{
		ProjectPath: "/test",
		Template:    "basic",
	}

	result, err := gen.Generate(opts)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result.ComposeYAML, "http_proxy=") {
		t.Error("ComposeYAML missing http_proxy env var")
	}
	if !strings.Contains(result.ComposeYAML, "https_proxy=") {
		t.Error("ComposeYAML missing https_proxy env var")
	}
	if !strings.Contains(result.ComposeYAML, "SSL_CERT_FILE=") {
		t.Error("ComposeYAML missing SSL_CERT_FILE env var")
	}
}
```

Update `TestComposeGenerator_Generate_Labels` — remove `Image` and `Isolation` fields:

```go
func TestComposeGenerator_Generate_Labels(t *testing.T) {
	templateDir := createTestTemplateDir(t, "go-project")

	templates := []config.Template{
		{Name: "go-project", Path: templateDir},
	}

	gen := NewComposeGenerator(templates)

	opts := ComposeOptions{
		ProjectPath: "/home/user/goapp",
		Template:    "go-project",
	}

	result, err := gen.Generate(opts)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result.ComposeYAML, LabelManagedBy+": \"true\"") {
		t.Error("ComposeYAML missing devagent.managed label")
	}
	if !strings.Contains(result.ComposeYAML, LabelTemplate+": \"go-project\"") {
		t.Error("ComposeYAML missing devagent.template label")
	}
	if !strings.Contains(result.ComposeYAML, LabelSidecarOf) {
		t.Error("ComposeYAML missing devagent.sidecar_of label")
	}
}
```

**Delete** `TestComposeGenerator_Generate_IgnoreHosts` entirely — passthrough is now in the template, not tested at the Go level.

Update `TestComposeGenerator_Generate_DependsOn` — remove `Isolation` field:

```go
func TestComposeGenerator_Generate_DependsOn(t *testing.T) {
	templateDir := createTestTemplateDir(t, "basic")

	templates := []config.Template{
		{Name: "basic", Path: templateDir},
	}

	gen := NewComposeGenerator(templates)

	opts := ComposeOptions{
		ProjectPath: "/test",
		Template:    "basic",
	}

	result, err := gen.Generate(opts)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result.ComposeYAML, "depends_on:") {
		t.Error("ComposeYAML missing depends_on section")
	}
	if !strings.Contains(result.ComposeYAML, "condition: service_started") {
		t.Error("ComposeYAML missing condition: service_started")
	}
}
```

Update `TestComposeGenerator_BasicTemplate` (the integration test that uses real templates). After Phase 1, Template no longer has `GetEffectiveIsolation()`:

```go
func TestComposeGenerator_BasicTemplate(t *testing.T) {
	templates := loadTestTemplates(t, "basic")

	gen := NewComposeGenerator(templates)

	opts := ComposeOptions{
		ProjectPath: "/home/user/test-project",
		Template:    "basic",
		Name:        "test-basic",
	}

	result, err := gen.Generate(opts)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result.ComposeYAML, "services:") {
		t.Error("Missing services section")
	}
	if !strings.Contains(result.ComposeYAML, "app:") {
		t.Error("Missing app service")
	}
	if !strings.Contains(result.ComposeYAML, "proxy:") {
		t.Error("Missing proxy service")
	}

	// Verify isolation settings from template (hardcoded in docker-compose.yml.tmpl)
	if !strings.Contains(result.ComposeYAML, "mem_limit: 4g") {
		t.Error("Missing memory limit from template")
	}
	if !strings.Contains(result.ComposeYAML, `cpus: "2"`) {
		t.Error("Missing CPU limit from template")
	}
	if !strings.Contains(result.ComposeYAML, "cap_drop:") {
		t.Error("Missing capability drops from template")
	}

	// Verify filter script from template has allowlist domains
	if !strings.Contains(result.FilterScript, "api.anthropic.com") {
		t.Error("Missing anthropic domain in filter script")
	}
	if !strings.Contains(result.FilterScript, "github.com") {
		t.Error("Missing github domain in filter script")
	}
}
```

Update `TestComposeGenerator_GoProjectTemplate`:

```go
func TestComposeGenerator_GoProjectTemplate(t *testing.T) {
	templates := loadTestTemplates(t, "go-project")

	gen := NewComposeGenerator(templates)

	opts := ComposeOptions{
		ProjectPath: "/home/user/go-app",
		Template:    "go-project",
		Name:        "test-go",
	}

	result, err := gen.Generate(opts)
	if err != nil {
		t.Fatalf("Generate failed: %v", err)
	}

	if !strings.Contains(result.ComposeYAML, "services:") {
		t.Error("Missing services section")
	}

	// Verify template isolation from docker-compose.yml.tmpl
	if !strings.Contains(result.ComposeYAML, "mem_limit:") {
		t.Error("Missing memory limit from template")
	}
	if !strings.Contains(result.ComposeYAML, "cpus:") {
		t.Error("Missing CPU limit from template")
	}

	// Verify filter script has Go proxy domain from template
	if !strings.Contains(result.FilterScript, "proxy.golang.org") {
		t.Error("Missing Go proxy domain in filter script")
	}
}
```

**Delete** `TestLoadAllowlist` entirely — `LoadAllowlist` function was removed.

**Step 6: Update proxy_test.go**

Delete these tests that tested removed functions:
- `TestGenerateFilterScript` (lines 10-73)
- `TestGenerateIgnoreHostsPattern` (lines 75-116)
- `TestWriteFilterScript` (lines 198-233)
- `TestGenerateFilterScript_BlockGitHubPRMerge` (lines 454-505)
- `TestGenerateFilterScript_PRMergeDetection` (lines 507-545)

Keep these tests (they test preserved functions):
- `TestGetProxyConfigDir` (lines 118-156)
- `TestGetProxyCertDir` (lines 158-196)
- `TestGetProxyCACertPath` (lines 235-254)
- `TestProxyCertExists` (lines 256-286)
- `TestCleanupProxyConfigs` (lines 288-330)
- `TestParseAllowlistFromScript` (lines 332-402)
- `TestReadAllowlistFromFilterScript` (lines 405-452)

After deleting the tests, the import block for `proxy_test.go` should be:

```go
import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)
```

Remove `"strings"` only if no remaining tests use it — `TestParseAllowlistFromScript` does not use it directly, but `TestReadAllowlistFromFilterScript` doesn't either. Check: `TestCleanupProxyConfigs` and `TestGetProxyConfigDir` use `strings.Contains`, so keep `"strings"`.

**Step 7: Remove unused import from compose_test.go**

After removing `testIsolationConfig` and the tests that reference `config.IsolationConfig`, the `"devagent/internal/config"` import in `compose_test.go` is still needed because `loadTestTemplates` returns `[]config.Template`. Keep it.

**Step 8: Run tests**

Run: `go test ./internal/container/... -v`
Expected: All tests pass

**Step 9: Commit**

```bash
git add internal/container/compose_test.go internal/container/proxy_test.go
git commit -m "test: update compose and proxy tests for filter.py.tmpl"
```
<!-- END_TASK_5 -->

<!-- END_SUBCOMPONENT_B -->

<!-- START_TASK_6 -->
### Task 6: Delete allowlist.txt files

**Files:**
- Delete: `config/templates/basic/allowlist.txt`
- Delete: `config/templates/go-project/allowlist.txt`

**Step 1: Delete the files**

```bash
git rm config/templates/basic/allowlist.txt config/templates/go-project/allowlist.txt
```

**Step 2: Run tests to confirm nothing breaks**

Run: `go test ./internal/container/... -v`
Expected: All tests pass (no code references these files anymore)

Run: `go test ./internal/config/... -v`
Expected: All tests pass

**Step 3: Commit**

```bash
git commit -m "chore: remove allowlist.txt files (replaced by filter.py.tmpl)"
```
<!-- END_TASK_6 -->

<!-- START_TASK_7 -->
### Task 7: Remove Isolation field from ComposeOptions

**Files:**
- Modify: `internal/container/compose.go`
- Modify: `internal/container/manager.go` (callers of ComposeOptions)

**Step 1: Remove Isolation field from ComposeOptions**

In `internal/container/compose.go`, replace the `ComposeOptions` struct (lines 68-75) with:

```go
// ComposeOptions holds options for generating compose files.
// This is a subset of CreateOptions needed for compose generation.
type ComposeOptions struct {
	ProjectPath string
	Template    string
	Name        string // Container name (used for compose service naming)
}
```

**Step 2: Update callers in manager.go**

Search for all places that set `Isolation` on `ComposeOptions` and remove that field assignment:

Run: `grep -n 'Isolation:' internal/container/manager.go`

For each hit, remove the `Isolation: ...` line from the struct literal.

**Step 3: Verify it compiles and tests pass**

Run: `go build ./...`
Expected: Build succeeds

Run: `go test ./internal/container/... -v`
Expected: All tests pass

**Step 4: Commit**

```bash
git add internal/container/compose.go internal/container/manager.go
git commit -m "refactor: remove Isolation field from ComposeOptions"
```
<!-- END_TASK_7 -->

<!-- START_TASK_8 -->
### Task 8: Update container CLAUDE.md

**Files:**
- Modify: `internal/container/CLAUDE.md`

**Step 1: Update the CLAUDE.md**

Update these sections to reflect changes:

In **Contracts/Exposes**: Remove `AllowlistConfig`. Remove `ProxyConfig` if it was removed.

In **Key Decisions**: Update the "Compose file generation" entry to mention `filter.py.tmpl` processed by `processTemplate()` instead of `GenerateFilterScript()`.

In **Key Files**:
- `compose.go` description: Replace "AllowlistConfig, buildProxyCommand" references with "processFilterTemplate(), CertInstallCommand in TemplateData"
- `proxy.go` description: Remove "GenerateFilterScript, filterScriptTemplate, GenerateIgnoreHostsPattern". Keep "ReadAllowlistFromFilterScript, parseAllowlistFromScript, WriteFilterScript" (if WriteFilterScript was kept). Note: WriteFilterScript was deleted in Task 4, so remove it from the description too.

In **Gotchas**: Add note that `filter.py.tmpl` is processed as a Go template but currently has no placeholders (all config is hardcoded in the template).

**Step 2: Commit**

```bash
git add internal/container/CLAUDE.md
git commit -m "docs: update container CLAUDE.md for filter.py.tmpl changes"
```
<!-- END_TASK_8 -->

<!-- START_TASK_9 -->
### Task 9: Verify Phase 2 compiles and all tests pass

**Files:** None (verification only)

**Step 1: Run full build**

Run: `go build ./...`
Expected: Build succeeds with exit code 0

**Step 2: Run all tests**

Run: `make test`
Expected: All tests pass

**Step 3: Run linter**

Run: `make lint`
Expected: No linter errors

If any failures, fix them before proceeding to Phase 3.
<!-- END_TASK_9 -->
